sys.path.append("./")
from utils import *
from training import *
from findLeaf import *

tr1 = Training("marktplaats-testcase1", "/Users/pascal/GDrive/sky/sky/tests/").load()
tr2 = Training("nieuwsdumper-testcase1", "/Users/pascal/GDrive/sky/sky/tests/").load()
tr3 = Training("nieuwsdumper-testcase2", "/Users/pascal/GDrive/sky/sky/tests/").load()
tr4 = Training("bouwmaterieel-testcase1", "/Users/pascal/GDrive/sky/sky/tests/").load()

tr5 = Training("marktplaats-testcase2", "/Users/pascal/GDrive/sky/sky/tests/")

tr5.addLinks(["http://www.marktplaats.nl/a/telecommunicatie/mobiele-telefoons-samsung/m861980349-hdc-galaxy-s5-nieuw-in-doos.html?c=a2384ef0ece270f44503df9f8598c624&previousPage=lr",
              "http://www.marktplaats.nl/a/telecommunicatie/mobiele-telefoons-samsung/m862001039-samsung-galaxy-s3-neo.html?c=a2384ef0ece270f44503df9f8598c624&previousPage=lr", "http://www.marktplaats.nl/a/telecommunicatie/mobiele-telefoons-toebehoren-en-onderdelen/m862001036-iphone-3-4-4s-usb-oplaad-snoer.html?c=a2384ef0ece270f44503df9f8598c624&previousPage=lr"])

tr5.viewAll()

links = ["http://www.forbes.com/sites/rogerkay/2014/11/10/sparkcognition-meets-ibms-watson-starts-conversation/"]


import justext

url = "http://www.forbes.com/sites/rogerkay/2014/11/10/sparkcognition-meets-ibms-watson-starts-conversation/"
html = urllib.urlopen(url).read()
paragraphs = justext.justext(html, justext.get_stoplist('English'))


title = "SparkCognition Meets IBM's Watson, Starts Conversation"
res = []
for x in paragraphs:
    if not x.is_boilerplate:
        res.append(x.text)

newres = []
for x in res[res.index(title)+1:]:
    newres.append(x)

for x in newres:
    print x.encode("ascii", "ignore")
    
res = findLeaf(tr3)

x = findSharedKeyValues(tr3, res)

secondLevelDown(tr3.soups[0], tr3.targets[0], x)

def uniqifyOverTraining(list_of_lists):
    uniques = []    
    for x in list_of_lists[0]: 
        if all([bool(x in y) for y in list_of_lists]):
            uniques.append(x)
        return uniques        

def findParentIdentifiers(x, soup, nLevel=3):
    parents = [] 
    for parent_attrs in [parent.attrs for parent in x.parents][:nLevel]:
        if len(soup.findAll(**{"attrs" : parent_attrs})) == 1:
            parents.append({"attrs" : parent_attrs})
    for parent_attrs in [{"name" : parent.name} for parent in x.parents][:nLevel]:
        if len(soup.findAll(**{"name" : parent.name})) == 1:
            parents.append({"name" : parent.name})
    return parents
    
def findSharedKeyValues(training, trainingLeafs):    
    case_options = [] 
    for soup, case in zip(training.soups, trainingLeafs): 
        options = [] 
        for leaf in case: 
            options.extend(findParentIdentifiers(leaf, soup)) 
            options.extend(findByTag(leaf, soup)) 
        case_options.append(options) 
    shared_options = [] 
    for option in case_options[0]: 
        if all([bool(option in case) for case in case_options]): 
            shared_options.append(option)
    return shared_options        
                        
def findByTag(node, soup, nLevel=5): 
    goodTags = []
    tags = []
    tags.extend([x.name for x in node.parents][:nLevel])
    try:
        tags.append(node.name)
    except:
        pass    
    for tag in tags: 
        if len(soup.findAll(tag)) == 1:
            goodTags.append({"name" : tag}) 
    return goodTags        

    
def firstLevelUp(soup, outcome):
    deep_res = soup.findAll(text=re.compile("\s*" + outcome.strip() + "\s*")) 
    unique_keys = []
    for res in deep_res: 
        for x in findKeyValues(res.parent, soup):
            unique_keys.append([{"attrs" : x}]) 
    # res = findLeafByTopSearch([x for x in soup.children], outcome)
    # for x in findKeyValues(res.parent, soup):
    #     for z in soup.find(attrs=x):
    #         unique_keys.append([{"attrs" : x}, {"name" : res.name}])
    for res in findByTag(outcome, soup):
        unique_keys.append([{"name" : res}])
    return unique_keys
        
def secondLevelDown(soup, outcome, unique_keys): 
    solution = []
    num = 0
    for unique_key in unique_keys:
        num += 1 
        #attempt = soup
        #for key in unique_key: 
        attempt = soup.find(**unique_key)
        #if textify(attempt) == outcome:
        if textify(attempt) == re.sub("\s+", " ", outcome).strip():
            solution.append([unique_key, textify])            
    return solution

def textify(x): 
    return re.sub("\s+", " ", x.text.strip()).strip()

def splitN(x, outcome):
    # consider splitting to get result
    pass 
    
def asNumeric(x): 
    return re.sub("[^0-9]", "", x)
    
def useSolution(solution, soup):
    return solution[1](soup.find(**solution[0]))

def buildSolution(training):
    res = findLeaf(training)
    print "len(res)", len(res)
    x = findSharedKeyValues(training, res)
    print "len(shared)", len(x)
    solutions = secondLevelDown(training.soups[0], training.targets[0], x)
    print "len(solutions)", len(solutions)
    return solutions

def testAutoScraperSolutions(autoScraper, training):
    num = 0
    any_succes = False
    for solution in autoScraper: 
        num += 1
        if all([useSolution(solution, soup) == target for soup, target in zip(training.soups, training.targets)]):
            result = "SUCCESFULL" 
            any_succes = True
        else: 
            result = "UNSUCCESFULL"
        print "Scraper method: ", num, " was ", result
    return any_succes    

testAutoScraperSolutions(autoScraper, training)
